# -*- coding: utf-8 -*-
"""Projectno1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IGWT5Bv5QMWd3lq880ugyiIHLCXyxft2
"""

from __future__ import print_function
import sys
import pandas as pd
import math
import pymysql.cursors

def checkmydatabase(name_of_file):
    df1=pd.read_csv("../uploaded_files/"+name_of_file)
    df1=df1[:500]
    rows = len(df1.axes[0]) ## row number
    cols = len(df1.axes[1]) ## column number
    count=0        ## Holds how many missing value exists in the column
    columns=" "         ## Holds the names of useful column in the dataset
    canconverted=" "    ## Holds the names of useless column that can be converted to numeric value
    useless_col=" "      ## Holds the names of useless column for this algorithm.
    m_canconverted=" "   ## Holds the names of useless and column that  can be converted to numeric value
    missing_values=" "  ## Holds number of missing values in convertible column
    index_duplicated=" "
    str_duplicated=" "
    suggestion=""
    
    duplicateRowsDF = df1[df1.duplicated(keep=False)].index  ###Checking duplicated
    if(len(duplicateRowsDF)==0):
        str_duplicated="You don''t have duplicated rows"
        index_duplicated=""
    else:
        str_duplicated="You have duplicated rows, whose index are : "
        for i in range(len(duplicateRowsDF)):
            index_duplicated=index_duplicated+" "+str(df1[df1.duplicated(keep=False)].index[i]) +", "
    
    for i in range(cols):
    
        cname=df1.axes[1][i]   ## Column name
        ctype=df1[cname].dtypes    ## Column type
        if((ctype=='float64') | (ctype=='int64')):
            columns=columns+" "+cname+" whose min value is: "+ str(df1[cname].min())+ " whose max value is: "+str(df1[cname].max())
        else:
            for j in range(rows):
                if(math.isnan(pd.to_numeric(df1[cname],errors='coerce')[j])): 
                    count=count+1
            if(count==0):
                canconverted=canconverted+" "+cname+",  "
            elif(count<rows/2):
                m_canconverted=m_canconverted+" "+" "+cname+",  "
                missing_values=missing_values+ " "+cname+ " have " + str(count) +" missing datas ,whose index are : "+str(df1[df1[cname].isnull()].index.tolist()) +" " ## Showing indexes of null values
                count=0
                
            elif(count>rows/2):
                useless_col=useless_col+" "+cname+" "
                count=0
            
    suggestion=suggestion +str_duplicated+index_duplicated+"\n\n"            
    suggestion=suggestion +"You can use these columns:"+columns+ " to train on RNN\n\n" 
    suggestion=suggestion +"You can''t use these columns:"+useless_col+ " to train on RNN\n\n"
    suggestion=suggestion +"You can''t use these columns:"+canconverted+ " to train on RNN. But you can convert these columns to numeric values \n\n"
    suggestion=suggestion +"You can''t use these columns:"+m_canconverted+ " to train on RNN. But you can convert these columns to numeric value. But these columns have missing values: "+missing_values+ " . You can fill this null values with mode or median after the convertion\n\n"
    return suggestion

if __name__ == '__main__':
    fname = sys.argv[1] # get file name
    result = checkmydatabase(fname) # run function with file name
    
    # make a connection with mysql server
    connection = pymysql.connect(host='localhost', user='group6', password='bbgmo@group6', database='group6', port=3307, cursorclass=pymysql.cursors.DictCursor, autocommit=True)
    try:
        with connection.cursor() as cursor:
            # update result of the file on database
            query = "UPDATE `files` SET `result`='"+result+"' WHERE server_file_name='"+fname+"'"
            cursor.execute(query)
    except Exception as e:
            query = "UPDATE `files` SET `result`='something wend wrong' WHERE server_file_name='"+fname+"'"
            cursor.execute(query)
            
    finally: connection.close()
